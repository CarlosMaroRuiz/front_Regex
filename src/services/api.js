import axios from 'axios';

const API_BASE_URL = 'http://localhost:8080/api';

// ‚úÖ Cache mejorado con categor√≠as espec√≠ficas
const cache = new Map();
const CACHE_TTL = 5 * 60 * 1000; // 5 minutos
const VALIDATION_CACHE_TTL = 30 * 1000; // 30 segundos para datos de validaci√≥n (m√°s din√°micos)

// Configurar axios con optimizaciones
const api = axios.create({
  baseURL: API_BASE_URL,
  timeout: 30000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// ‚úÖ Interceptor mejorado para cache inteligente
api.interceptors.request.use((config) => {
  if (config.method === 'get') {
    const cacheKey = `${config.url}?${JSON.stringify(config.params || {})}`;
    const cached = cache.get(cacheKey);
    
    if (cached) {
      // ‚úÖ TTL diferenciado por tipo de endpoint
      const ttl = config.url.includes('invalid-data') || 
                  config.url.includes('validation') || 
                  config.url.includes('errors') 
                  ? VALIDATION_CACHE_TTL 
                  : CACHE_TTL;
      
      if ((Date.now() - cached.timestamp) < ttl) {
        console.log('üöÄ Cache hit para:', cacheKey);
        return Promise.resolve({
          ...config,
          adapter: () => Promise.resolve({
            data: cached.data,
            status: 200,
            statusText: 'OK (cached)',
            headers: {},
            config
          })
        });
      } else {
        // Cache expirado, remover
        cache.delete(cacheKey);
        console.log('üóëÔ∏è Cache expirado removido:', cacheKey);
      }
    }
  }
  
  return config;
});

// ‚úÖ Interceptor mejorado para guardar en cache
api.interceptors.response.use((response) => {
  if (response.config.method === 'get' && response.status === 200) {
    const responseSize = JSON.stringify(response.data).length;
    if (responseSize < 500000) { // Cache respuestas < 500KB
      const cacheKey = `${response.config.url}?${JSON.stringify(response.config.params || {})}`;
      cache.set(cacheKey, {
        data: response.data,
        timestamp: Date.now()
      });
      console.log('üíæ Guardado en cache:', cacheKey);
    }
  }
  
  return response;
}, (error) => {
  console.error('‚ùå API Error:', error.response?.status, error.message);
  return Promise.reject(error);
});

// ‚úÖ Funci√≥n mejorada para limpiar cache espec√≠fico
export const clearCache = (pattern = null) => {
  if (pattern) {
    // Limpiar cache que coincida con el patr√≥n
    const keysToDelete = [];
    for (const key of cache.keys()) {
      if (key.includes(pattern)) {
        keysToDelete.push(key);
      }
    }
    keysToDelete.forEach(key => cache.delete(key));
    console.log(`üßπ Cache limpiado para patr√≥n "${pattern}":`, keysToDelete.length, 'entradas');
  } else {
    // Limpiar todo el cache
    cache.clear();
    console.log('üßπ Todo el cache limpiado');
  }
};

// ‚úÖ Funci√≥n para invalidar cache de validaci√≥n espec√≠ficamente
export const invalidateValidationCache = () => {
  clearCache('invalid-data');
  clearCache('validation');
  clearCache('errors');
  clearCache('con-validacion');
  console.log('üîÑ Cache de validaci√≥n invalidado');
};

// ‚úÖ Funci√≥n para emitir eventos de actualizaci√≥n
const emitDataUpdate = (type, data) => {
  const event = new CustomEvent('api-data-updated', {
    detail: { type, data, timestamp: Date.now() }
  });
  window.dispatchEvent(event);
  console.log('üì° Evento emitido:', type, data);
};

export const contactosApi = {
  // ‚ö° ENDPOINTS OPTIMIZADOS PARA GRANDES DATASETS
  
  getContactosPaginated: async (page = 0, size = 50, search = '') => {
    const params = { page, size };
    if (search && search.trim()) params.search = search.trim();
    
    try {
      const response = await api.get('/contactos/paginated', { params });
      return response;
    } catch (error) {
      console.error('‚ùå Error en paginaci√≥n:', error);
      throw error;
    }
  },

  searchContactos: async (searchTerm, page = 0, size = 50) => {
    return api.get('/contactos/search', {
      params: { q: searchTerm, page, size }
    });
  },

  getContactosCount: () => api.get('/contactos/count'),

  // üìä ENDPOINTS B√ÅSICOS CON MANEJO MEJORADO
  
  getAll: () => api.get('/contactos'),
  
  getById: (clave) => {
    console.log('üîç Obteniendo contacto por clave:', clave);
    return api.get(`/contactos/${clave}`);
  },
  
  // ‚úÖ Crear contacto con invalidaci√≥n de cache y eventos
  create: async (contacto) => {
    try {
      console.log('‚ûï Creando contacto:', contacto);
      const response = await api.post('/contactos', contacto);
      
      if (response.data.success) {
        // Invalidar cache relevante
        clearCache('contactos');
        invalidateValidationCache();
        
        // Emitir evento de actualizaci√≥n
        emitDataUpdate('contacto-created', response.data.data);
        
        console.log('‚úÖ Contacto creado exitosamente');
      }
      
      return response;
    } catch (error) {
      console.error('‚ùå Error creando contacto:', error);
      throw error;
    }
  },
  
  // ‚úÖ Actualizar contacto con invalidaci√≥n de cache y eventos
  update: async (clave, contacto) => {
    try {
      console.log('üìù Actualizando contacto:', clave, contacto);
      const response = await api.put(`/contactos/${clave}`, contacto);
      
      if (response.data.success) {
        // Invalidar cache relevante
        clearCache('contactos');
        clearCache(`/contactos/${clave}`);
        invalidateValidationCache();
        
        // Emitir evento de actualizaci√≥n
        emitDataUpdate('contacto-updated', {
          ...response.data.data,
          originalClave: clave
        });
        
        console.log('‚úÖ Contacto actualizado exitosamente');
      }
      
      return response;
    } catch (error) {
      console.error('‚ùå Error actualizando contacto:', error);
      throw error;
    }
  },
  
  // ‚úÖ Eliminar contacto con invalidaci√≥n de cache y eventos
  delete: async (clave) => {
    try {
      console.log('üóëÔ∏è Eliminando contacto:', clave);
      const response = await api.delete(`/contactos/${clave}`);
      
      if (response.data.success) {
        // Invalidar cache relevante
        clearCache('contactos');
        clearCache(`/contactos/${clave}`);
        invalidateValidationCache();
        
        // Emitir evento de actualizaci√≥n
        emitDataUpdate('contacto-deleted', { clave });
        
        console.log('‚úÖ Contacto eliminado exitosamente');
      }
      
      return response;
    } catch (error) {
      console.error('‚ùå Error eliminando contacto:', error);
      throw error;
    }
  },
  
  search: (params) => api.get('/contactos/buscar', { params }),
  getStats: () => api.get('/contactos/stats'),
  
  // üîß ENDPOINTS DE VALIDACI√ìN MEJORADOS
  
  // ‚úÖ Validaci√≥n con cache de corta duraci√≥n
  getValidationReport: async () => {
    try {
      console.log('üìä Obteniendo reporte de validaci√≥n...');
      const response = await api.get('/contactos/validation');
      return response;
    } catch (error) {
      console.error('‚ùå Error obteniendo reporte de validaci√≥n:', error);
      throw error;
    }
  },

  getValidationErrors: async () => {
    try {
      console.log('‚ö†Ô∏è Obteniendo errores de validaci√≥n...');
      const response = await api.get('/contactos/errors');
      return response;
    } catch (error) {
      console.error('‚ùå Error obteniendo errores de validaci√≥n:', error);
      throw error;
    }
  },

  getContactosWithValidation: () => api.get('/contactos/con-validacion'),
  
  // ‚úÖ Datos inv√°lidos con manejo de fallback mejorado
  getInvalidData: async () => {
    try {
      console.log('üîç Obteniendo datos inv√°lidos...');
      const response = await api.get('/contactos/invalid-data');
      
      if (response.data.success && response.data.data) {
        console.log('‚úÖ Datos inv√°lidos obtenidos:', response.data.data.length);
      }
      
      return response;
    } catch (error) {
      console.error('‚ùå Error obteniendo datos inv√°lidos:', error);
      
      // ‚úÖ Fallback: intentar con endpoint de validaci√≥n
      try {
        console.log('üîÑ Intentando fallback con endpoint de validaci√≥n...');
        const fallbackResponse = await api.get('/contactos/validation');
        
        if (fallbackResponse.data.success && fallbackResponse.data.data?.invalidRowsData) {
          console.log('‚úÖ Datos inv√°lidos obtenidos via fallback');
          // Restructurar la respuesta para mantener consistencia
          return {
            ...fallbackResponse,
            data: {
              ...fallbackResponse.data,
              data: fallbackResponse.data.data.invalidRowsData
            }
          };
        }
      } catch (fallbackError) {
        console.error('‚ùå Fallback tambi√©n fall√≥:', fallbackError);
      }
      
      throw error;
    }
  },
  
  // ‚úÖ Recargar Excel con invalidaci√≥n completa de cache
  reloadExcel: async () => {
    try {
      console.log('üîÑ Recargando datos desde Excel...');
      const response = await api.post('/contactos/reload');
      
      if (response.data.success) {
        // Invalidar TODO el cache despu√©s de recargar
        clearCache();
        
        // Emitir evento de recarga completa
        emitDataUpdate('excel-reloaded', response.data.data);
        
        console.log('‚úÖ Excel recargado exitosamente');
      }
      
      return response;
    } catch (error) {
      console.error('‚ùå Error recargando Excel:', error);
      throw error;
    }
  },
  
  // üîß ENDPOINTS DE DEBUG
  debugInvalidData: () => api.get('/contactos/debug/invalid-data'),
  forceInvalidData: () => api.get('/contactos/debug/force-invalid'),
  checkExcelFile: () => api.get('/contactos/debug/check-excel'),
  
  // ‚úÖ Nuevo endpoint para validar claves
  validateKey: (clave) => {
    console.log('üîç Validando clave:', clave);
    return api.get(`/contactos/validate/key/${clave}`);
  },
  
  healthCheck: () => api.get('/health'),
};

// ‚úÖ Funciones auxiliares para manejo de eventos
export const subscribeToDataUpdates = (callback) => {
  const handleUpdate = (event) => {
    callback(event.detail);
  };
  
  window.addEventListener('api-data-updated', handleUpdate);
  
  // Retornar funci√≥n de cleanup
  return () => {
    window.removeEventListener('api-data-updated', handleUpdate);
  };
};

// ‚úÖ Funci√≥n para obtener estad√≠sticas del cache
export const getCacheStats = () => {
  const now = Date.now();
  let validEntries = 0;
  let expiredEntries = 0;
  
  for (const [key, value] of cache.entries()) {
    const age = now - value.timestamp;
    const ttl = key.includes('invalid-data') || 
                key.includes('validation') || 
                key.includes('errors') 
                ? VALIDATION_CACHE_TTL 
                : CACHE_TTL;
    
    if (age < ttl) {
      validEntries++;
    } else {
      expiredEntries++;
    }
  }
  
  return {
    totalEntries: cache.size,
    validEntries,
    expiredEntries,
    cacheHitRate: validEntries / Math.max(cache.size, 1)
  };
};

export default api;